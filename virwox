#!/usr/bin/perl

# Copyright (c) 2014 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use Try::Tiny;
use Term::ReadLine;

try {
	use Finance::CoinBase;
} catch {
	printf STDERR "You need to install Finance::CoinBase\n";
}

my ($apikey, $secret);

my $configfile = $ENV{'HOME'}."/.virwox.conf";
if (-f $configfile) {
	open(CONFIG, $configfile);
	while(<CONFIG>) {
		my $line;
		chomp($line = $_);
		if ($line =~ /^([a-z]+)\s*=\s*(.*)$/) {
			my ($var,$val) = ($1,$2);
			$val =~ s/#.*$//g;
			if ($var eq "apikey") {
				$apikey = $val;
			} elsif ($var eq "secret") {
				$secret = $val;
			} else {
				printf STDERR "Unrecognized: '%s' = '%s'\n",
				    $var, $val;
			}
		}
	}
	close(CONFIG);
}

if (!defined($apikey) || !defined($secret)) {
	printf STDERR "Either apikey or secret undefined, functions requiring this will not work\n";
}
my $virwox = Finance::CoinBase->new( {
	apifile => "$ENV{'HOME'}/git/sw/api-description/services/virwox.json",
	apikey => $apikey,
	secret => $secret,
    } );

sub
act
{
	my (@argv) = @_;
	my %result;
	my @resultkeys;
	my $res;
	if (!defined($argv[0])) {
		return;
	}
	my $cmd = shift @argv;
	if ($cmd eq "quit") {
		exit(0);
	} elsif($cmd eq "getBestPrices") {
		if (!defined($argv[0])) {
			printf STDERR "Need symbols";
			return;
		}
		my %parms;
		$parms{'id'} = 1;
		$parms{'method'} = $cmd;
		$parms{'buyDepth'} = 1;
		$parms{'sellDepth'} = 1;
		my $i=0;
		foreach my $arg (@argv) {
			my $sym = "symbols%5b".$i++."%5d";
			$parms{$sym} = $arg;
		}
		#$res = $virwox->{api}->$cmd(method => $cmd, symbols => $arg);
		$res = $virwox->api($cmd, { %parms });
	} else {
		$res = $virwox->api($cmd, {method => $cmd, params => undef, id => 1} );
	}

	if (!defined($res)) {
		print "<undef>\n";
		return;
	}

	$virwox->dumpit($res);
	return;
	apikeywarn:
	printf STDERR "%s requires an api key, noop\n", $argv[0];
}

if (@ARGV) {
	act( @ARGV );
	exit(0);
}

my $term = Term::ReadLine->new('cb', *STDIN, *STDOUT);
$term->ornaments(0);

my $prompt = "virwox> ";
my $line;
while (1)
{
	chomp($line = $term->readline($prompt));
	if (!defined($line)) {
		exit(0);
	}
	act( split(/[ ]+/,$line) );
}
